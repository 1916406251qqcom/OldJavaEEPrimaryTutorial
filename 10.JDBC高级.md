# 1. JDBC进阶操作

## 1.1 用CallableStatement执行存储过程

　　要执行存储过程，就先用Connection对象获得CallableStatement，然后执行存储过程，结果依然在结果集ResultSet中，用案例讲解执行存储过程。

　　例1：带有输入参数（或者无参数）的存储过程的执行，该存储过程中有对表的查询。

　　比如之前的例子：

```sql
delimiter $;
create procedure proTest(in empId int) -- 参数格式：in/out/inout 参数名 参数类型
begin
  select * from employee where eid = empId;
END $;

-- 调用
call proTest(1);
```

　　程序代码：

```java
public static void main(String[] args) {
    Connection conn = null;
    CallableStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = JdbcUtil.getConnection();
        // 使用prepareCall()获得CallableStatement对象，该对象也是预编译的SQL。PreparedStatement继承了Statement，CallableStatement继承了PreparedStatement。
        stmt = conn.prepareCall("call proTest(?)");
        stmt.setInt(1, 1); // 设置参数
        // 同样调用executeQuery()获得结果集
        rs = stmt.executeQuery();
        while(rs.next()) {
            // 输出查到的员工编号
            System.out.println(rs.getInt(1));
            // 输出查到的员工姓名
            System.out.println(rs.getString(2));
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, rs); // 关闭连接
    }
}
```

　　可以看出，对于有输入参数或者无参数的存储过程，使用方法也简单，和之前的步骤一样，只是用ResultSet获得结果集，如果有输入参数，直接用占位符先代替，之后设置即可。

　　当有输出参数的时候，就需要先用CallableStatement注册输出参数，用executeQuery()或executeUpdate()执行完存储过程后，再用CallableStatement的getXxx()方法获得输出结果。CallableStatement的getXxx()方法专门用于获得输出参数结果的。

　　例子如下：

　　使用的存储过程：

```sql
delimiter $;
create procedure testIf(in num int, out str varchar(20))
begin
  if num = 1 then
    set str = '星期一';
  elseif num = 2 then
    set str = '星期二';
  elseif num = 3 then
    set str = '星期三';
  else
    set str = '输入错误';
  end if;
end $;
-- 调用示例
call testIf(4, @str);
```

　　程序代码：

```java
public static void main(String[] args) {
    Connection conn = null;
    CallableStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareCall("call testIf(?, ?)");
        stmt.setInt(1, 2); // 设置参数1
        // 参数2是输出参数，调用registerOutParameter注册输出参数
        // 方法参数指定了哪个参数是输出参数，并且是什么类型
        stmt.registerOutParameter(2, Types.VARCHAR);
        // Types类是java.sql提供的类，其中的静态变量描述了数据库中的数据类型
        // 然后，调用executeQuery()或者executeUpdate()执行
        stmt.executeUpdate();
        // 最后还是通过stmt得到输出参数的结果，index要和上面注册的索引匹配
        String result = stmt.getString(2);
        System.out.println(result);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null); // 关闭连接
    }
}
```

## 1.2 批处理

　　有时，程序需要一次性执行多条SQL语句（例如批量增加、删除数据等），如果按照以前方法，每执行一次SQL就使用一系列的“获得连接、执行SQL、释放资源”操作的话，将导致程序与数据库交互次数频繁、开销大、效率降低。

　　这时我们可以采用批处理的方法提高效率。批处理就可以实现在一次连接过程中执行多条SQL语句，以此提高数据库吞吐量。。

　　例1：在一次连接中执行三条SQL，分别是增加两条学生记录，再删除第一条学生记录。

```java
public static void main(String[] args) {
    Connection conn = null;
    Statement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.createStatement();
        String sql1 = "INSERT INTO student(id, name) VALUES(1, '张三')";
        String sql2 = "INSERT INTO student(id, name) VALUES(2, '李四')";
        String sql3 = "DELETE FROM student where id=1";
        // 使用addBatch方法，将每条SQL加入到批处理中。实际上加入批处理就是把要执行的SQL添加进了Statement实现类维护的一个List对象中。该List对象起到了缓存SQL的作用。这点可通过查看MySQL JDBC源码验证。
        stmt.addBatch(sql1);
        stmt.addBatch(sql2);
        stmt.addBatch(sql3);
        // 调用executeBatch()就会执行批处理，即一次性执行完添加进去的所有SQL，这些是MySQL的JDBC实现类按照规范已经实现好的，我们无需关注具体实现，会调用即可。
        int[] rows = stmt.executeBatch(); // 方法返回一个int数组，表示每条SQL执行后影响的行数
        for (int i = 0; i < rows.length; i++) {
            System.out.println("第" + (i + 1) + "条语句执行影响了" + rows[i] + "行");
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null); // 关闭连接
    }
}
```

　　运行完上述程序，student表中只有一条“李四”的数据，因为其中第一条添加的记录随即也被删除了。

　　上面的例子中执行了不同的SQL语句，我们使用了Statement对象。如果我们是执行相同的SQL，可以使用PreparedStatement，例如要插入10条学生记录，预编译SQL是相同的，只是每条参数值不同。例如可这样使用：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("INSERT INTO student(id, name) VALUES(?, ?)");
        // 循环十次，由于只有参数不同，只要设置不同的参数，再加入批处理即可。
        for (int i = 0; i < 10; i++) {
            stmt.setInt(1, i);
            stmt.setString(2, "学生" + i);
            stmt.addBatch();
        }
        // 最后执行
        int[] rows = stmt.executeBatch();
        for (int i = 0; i < rows.length; i++) {
            System.out.println("第"+ (i + 1) + "条SQL影响了" + rows[i] + "行");
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null); // 关闭连接
    }
}
```

　　如果要进行大批量数据的操作，例如添加10000个学生记录（甚至更多），这时就不能单纯地像上面一样直接把这么多数据缓存到批处理缓存中，而应该分批操作，例如每满足1000条学生才执行一次批处理。

　　因为大数据量不可能一次性处理完毕，否则导致内存溢出，因此采取这样的策略。其实，大数据量的处理基本都会采用这样的方法：每次批量地处理一定数量的数据。这实际和IO中使用的缓冲区是一样的道理，避免了一次只处理一丁点或者极大数量的数据。

　　程序代码如下：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("INSERT INTO student(id, name) VALUES(?, ?)");
        // 循环10000次。
        for (int i = 1; i <= 10000; i++) {
            stmt.setInt(1, i);
            stmt.setString(2, "学生" + i);
            stmt.addBatch();
            // 每达到1000条就执行一次批处理
            if ( i % 1000 == 0) {
                stmt.executeBatch();
                // 执行完后一定要清空缓存数据，否则数据一直累加
                stmt.clearBatch();
            }
        }
        stmt.executeBatch(); // 最后再执行executeBatch()，这是因为最后可能还有剩余的不满1000条的记录。比如如果要插入10021条记录，最后取余后，还会有21条记录要存储，这是确保全部插入。
        stmt.clearBatch();
        System.out.println("执行结束");
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null); // 关闭连接
    }
}
```

　　注意的是每次批处理不要忘了清空缓存。

## 1.3 获取自增长值

　　比如部门表和员工表，部门表的主键是自增长的。有一种情况：在程序中添加了一个部门信息后，需要马上得到该部门自增长的主键，然后给该部门添加员工。

　　那么此时获得自增长键就十分有必要。现在就用程序获得部门表自增长的键值。

　　（1）部门表SQL：

```sql
create table dept(
  did int primary key auto_increment,
  dname varchar(20)
);
```

　　（2）程序代码：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = JdbcUtil.getConnection();
        String sql = "INSERT INTO dept(dname) VALUES(?)";
        // 这里调用prepareStatement方法时，用参数2表示需要获得执行此SQL完毕的自增长键的值
        stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        // 设置ps参数
        stmt.setString(1, "系统研发部");
        // 先执行完ps
        stmt.executeUpdate();
        // 然后用ps的getGeneratedKeys()方法获得自增长的结果集
        rs = stmt.getGeneratedKeys();
        int keys = 0;
        if (rs.next()) {
            keys = rs.getInt(1);
        }
        System.out.println("获得的自增长键是：" + keys);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, rs); // 关闭连接
    }
}
```

## 1.4 LOB的存取

　　LOB是Large Object的意思，即是用于存储大数据的对象。LOB分为CLOB和BLOB，CLOB用于存储大的文本数据（Character Large Object）；BLOB用于存储大的二进制数据（Binary Large Object），例如文件、图片、视频等。

　　正如之前所讲，在MySQL中，本身就有BLOB数据类型，而MySQL中的TEXT数据类型就对应着CLOB数据类型。

　　MySQL中，分别有四种TEXT数据类型和四种BLOB数据类型，它们之间的区别就是最大存储的数据长度不同，这个可参阅前面章节的知识。MySQL支持的LOB类型都是可变长度类型，即以数据的实际长度进行存储。

　　下面我们了解如何通过JDBC进行MySQL的LOB类型存取操作。

　　（1）插入大文本数据

　　首先创建一张用于测试的表：

```sql
-- 新建测试表
CREATE TABLE t1 (
  id INT PRIMARY KEY,
  content LONGTEXT
);
```

　　并在src目录下新建一个a.txt文件（要求是UTF8编码的），里面书写内容，下面的程序将文本内容保存到数据库中。代码如下：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("INSERT INTO t1(id, content) VALUES(?,?)");
        // 正常设置参数
        stmt.setInt(1, 1);
        // 设置LONGTEXT的内容时，要调用setCharacterStream方法。其中需要reader对象，因此这里读取文件为Reader流。
        Reader reader = new FileReader("src/a.txt");
        stmt.setCharacterStream(2, reader); // 设置内容
        stmt.executeUpdate();
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null);
    }
}
```

　　（2）读取大文本数据。

　　这里读取刚刚保存的数据。代码如下：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("SELECT * FROM t1 WHERE id=?");
        stmt.setInt(1, 1);
        rs = stmt.executeQuery();
        if (rs.next()) {
            // 下面就是流的读取和写入处理
            Writer writer = new FileWriter("d:/b.txt"); // 写到d盘的b.txt中
            Reader reader = rs.getCharacterStream(2); // 得到对应的Reader流
            char[] buff = new char[1024];
            int length = 0;
            while ( (length = reader.read(buff)) != -1 ) {
                writer.write(buff, 0, length);
            }
            reader.close();
            writer.close();
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, rs);
    }
}
```

　　（3）插入二进制数据。首先创建测试表如下：

```sql
CREATE TABLE t2 (
  id INT PRIMARY KEY,
  content LONGBLOB
);
```

　　在src下准备一张test.jpg文件，下述程序将图片数据保存到t2表中：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("INSERT INTO t2(id, content) VALUES(?,?)");
        stmt.setInt(1, 1);
        // 这时调用的是setBinaryStream方法，需要InputStream对象
        InputStream in = new FileInputStream("src/test.jpg");
        stmt.setBinaryStream(2, in);
        stmt.executeUpdate();
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, null);
    }
}
```

　　这样就把图片数据保存在了BLOB中了。

　　（4）读取二进制数据。把刚才保存的数据读取并生成一个jpg文件。代码如下：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = JdbcUtil.getConnection();
        stmt = conn.prepareStatement("SELECT content FROM t2 WHERE id = ?");
        stmt.setInt(1, 1);
        rs = stmt.executeQuery();
        if (rs.next()) {
            InputStream in = rs.getBinaryStream("content");
            // 下面就是操作流了。
            OutputStream out = new FileOutputStream("d:/test.jpg");
            byte[] buff = new byte[1024];
            int length = 0;
            while ( (length = in.read(buff)) != -1 ) {
                out.write(buff, 0, length);
            }
            in.close();
            out.close();
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        JdbcUtil.release(conn, stmt, rs);
    }
}
```

　　但是在实际应用中，一般也不会把文件保存到数据库中，而是直接把文件保存在服务器的硬盘上，数据库中的字段保存文件名，使得服务器能找到该文件即可。

## 1.5 元数据Metadata

　　有时想获得所连接数据库的一些信息，比如数据库版本、名称等信息，或者获得结果集的列信息。想要获得这些信息，就需要用到“元数据”。

　　JDBC提供了三种元数据对象，分别是数据库元数据、参数元数据和结果集元数据。见案例。

　　案例1：数据库元数据。通过Connection对象的getMetaData方法即可得到DatabaseMetaData，可从中获取数据库有关信息。

　　代码：

```java
package com.zhang.test;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;

public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        // 得到数据库元对象
        DatabaseMetaData metaData = conn.getMetaData();
        System.out.println(metaData.getUserName()); //获得用户名
        System.out.println(metaData.getURL()); //获得连接字符串url
        System.out.println(metaData.getDatabaseProductName()); // 数据库名称
        System.out.println(metaData.getDatabaseProductVersion()); // 数据库版本号
        System.out.println(metaData.getDriverName()); // 驱动名称
        System.out.println(metaData.getDriverVersion()); // 驱动版本
        System.out.println(metaData.isReadOnly()); // 是否只读的
        conn.close();
    }
}
```

　　案例2：参数元数据，可调用PreparedStatement对象的getParameterMetaData()方法得到元数据对象。可获得参数个数。

```java
package com.zhang.test;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        PreparedStatement ps = conn.prepareStatement("insert into account values(?,?)");
        ps.setString(1, "zhang");
        ps.setInt(2, 1);
        // 得到参数元数据对象
        ParameterMetaData pmd = ps.getParameterMetaData();
        System.out.println(pmd.getParameterCount()); // 获得参数个数
        ps.close();
        conn.close();
    }
}
```

　　案例3：结果集元数据。通过ResultSet的getMetaData()方法得到，可获得当前列的个数和名称等信息。 

```java
package com.zhang.test;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        PreparedStatement ps = conn.prepareStatement("select * from account");
        ResultSet rs = ps.executeQuery();
        ResultSetMetaData rsmd = rs.getMetaData();
        // getColumnCount()获得有多少列。由于索引从1开始，因此遍历就从1开始
        // 这里遍历列，在循环中获得每列信息
        for(int i = 1; i <= rsmd.getColumnCount(); i++) {
            System.out.println(rsmd.getColumnLabel(i)); // 列名
            System.out.println(rsmd.getColumnClassName(i)); // 列在Java中的类型
            System.out.println(rsmd.getColumnTypeName(i)); // 列在数据库中的类型
        }
        rs.close();
        ps.close();
        conn.close();
    }
}
```

# 2. 事务（Transaction）

## 2.1 数据库中的事务

　　事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部失败。事务的最简单的例子就是银行转账。例如A给B转账，那么A的存款减少和B的存款增加这两件事必须是原子性的，即要么都成功，转账就成功，要么都失败，转账就失败，失败那么A和B的账户还是保持原来的状态。不允许出现只有一方成功或者失败。

　　也就是说，组成事务的各个单元必须全部成功，否则整个操作就应该回滚（rollback）到之前的状态。因此，事务保证了数据的准确性，事务在数据库中非常重要。

　　MySQL中，事务是自动开启和提交的，即每条语句处于独立的事务中且自动提交事务。例如我们之前执行的所有SQL都是自动提交的，即我们让数据库执行一条SQL时，数据库自动在执行该语句前开启事务，执行完毕后提交事务，这样执行完后我们就能马上看见该SQL对数据库所作的更改。

　　我们也可通过手动提交事务，让一组语句处于同一个事务中。例如我们让上面的转账操作处于同一事务中执行，那么就需要进行这样的操作：

　　（1）开启事务。在MySQL中执行语句：

```sql
START TRANSACTION;
```

　　该语句就表示开启一个事务，这表示以后执行的语句都处于同一个事务中（除非遇到commit或rollback语句）。

　　（2）执行本事务中的一系列SQL。例如转账操作（自己预先建立账户表）：

```sql
-- A 向 B转账100元
UPDATE account SET money = money - 100 WHERE name='A';
UPDATE account SET money = money + 100 WHERE name='B';
```

　　（3）执行commit或者rollback语句。

　　如果执行commit，表示提交该事务，即执行此事务，若事务执行成功，表示其中SQL均执行成功，转账将成功；若事务执行中有误，则事务中的语句均不会执行成功，数据库还是开启事务之前的状态（即失败自动回滚）。

　　如果执行rollback，则直接回滚这个事务，即放弃本事务中所有语句所作的更改，回到开启事务之前的状态。

　　其实，start transaction就是定义了一个标记，用于提交或回退。执行commit或者rollback都将使本事务结束，本事务产生的最终结果将会作用到数据库上。

　　下面介绍一下事务的特性，常作为面试用：

　　（1）原子性：指处于同一个事务中的多条语句是不可分割的。

　　（2）一致性：事务必须使数据库的一个一致性状态变换到另外一个一致性状态。比如，转账前两个账户余额之和为2k，转账之后也应该是2K。

　　（3）隔离性：指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰。（对于隔离性，下面的2.3节专门对隔离性进行讲解）

　　（4）持久性：事务一旦提交，就应该被永久保存起来。

## 2.2 JDBC中控制事务

　　以前使用的JDBC也是自动提交事务的。如果想手动控制事务，则要先调用Connection对象的setAutoCommit()方法，设置自动提交为false，实现手动控制事物提交。其中使用commit()方法提交事务，使用rollback()方法回滚事务。

　　下面是手动提交的例子：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        conn.setAutoCommit(false); // 一定要在执行之前设置手动提交
        stmt = conn.prepareStatement("UPDATE account SET money = money - 100 WHERE name = 'A'");
        stmt.executeUpdate(); // 执行
        stmt = conn.prepareStatement("UPDATE account SET money = money + 100 WHERE name = 'B'");
        stmt.executeUpdate(); // 执行
        // 最后要提交。否则无效果。
        conn.commit();
    } catch (Exception e) {
        if (conn != null) {
            try {
                conn.rollback(); // 遇到异常，回滚
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }
        e.printStackTrace();
    } finally {
        JdbcUtil.release(conn, stmt);
    }
}
```

　　上述执行成功后，数据库中发生了一次“成功的转账”。其实transaction也是“交易”的意思，简称是“TX”，T是首字母，X是transaction的“近似”发音。

　　为了验证能成功回滚，我们故意在执行完第一个SQL后执行一句“int x = 1/0”的错误代码，使下一句SQL无法执行，以此验证能够回滚到开启事务之前的状态。其实，rollback可以不用调用，因为出现异常会自动回滚，则代码如下：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        conn = JdbcUtil.getConnection();
        conn.setAutoCommit(false); // 一定要在执行之前设置手动提交
        stmt = conn.prepareStatement("UPDATE account SET money = money - 100 WHERE name = 'A'");
        stmt.executeUpdate(); // 执行
        int x = 1 / 0; // 故意出错
        stmt = conn.prepareStatement("UPDATE account SET money = money + 100 WHERE name = 'B'");
        stmt.executeUpdate(); // 执行
        // 最后要提交。否则无效果。
        conn.commit();
    } catch (Exception e) {
        // 省略了rollback
        e.printStackTrace();
    } finally {
        JdbcUtil.release(conn, stmt);
    }
}
```

　　有时，只想回滚事务的一部分，那么可以使用保存点（回滚点）。例如两次转账，如果已经保证第一次转账是正确的，如果出现了错误，就回滚到第一次转账之后。使用setSavePoint()设置一个保存点，然后使用rollback(sp)回滚到该保存点。例如下述代码：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    Savepoint sp = null;
    try {
        conn = JdbcUtil.getConnection();
        conn.setAutoCommit(false); // 一定要在执行之前设置手动提交
        // 第一次转账
        stmt = conn.prepareStatement("UPDATE account SET money = money - 100 WHERE name = 'A'");
        stmt.executeUpdate(); // 执行
        stmt = conn.prepareStatement("UPDATE account SET money = money + 100 WHERE name = 'B'");
        stmt.executeUpdate(); // 执行
        // 第一次转账结束设置保存点
        sp = conn.setSavepoint();
        // 第二次转账
        stmt = conn.prepareStatement("UPDATE account SET money = money - 100 WHERE name = 'A'");
        stmt.executeUpdate(); // 执行
        int x = 1 / 0; // 模拟出错
        stmt = conn.prepareStatement("UPDATE account SET money = money + 100 WHERE name = 'B'");
        stmt.executeUpdate(); // 执行
    } catch (Exception e) {
        // 这时要回滚到保存点
        if (conn != null) {
            try {
                conn.rollback(sp);
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }
        e.printStackTrace();
    } finally {
        // 这时将提交写在finally中，因为部分回滚也是要提交的，否则保存点之前的也不会提交进数据库。
        if (conn != null) {
            try {
                conn.commit();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        JdbcUtil.release(conn, stmt);
    }
}
```

## 2.3 事务的隔离级别、JDBC中控制事务的隔离级别

　　之前我之所以说，在事务中没提交前执行的SQL不是真正地将操作结果保存到数据库中，那是因为没有提交（或回滚）前，是不知道最终的操作结果的。但实际上，事务中执行的SQL就是在数据库上操作的，并且在事务中能看到执行过的SQL产生的效果（即使没有提交）。比如之前转账的例子，事务中执行让A减少100元后，即使未提交事务，这时在本事务中用SELECT查询数据，会发现查出的数据确实是A减少100元。

　　这说明事务执行过程中就按照SQL操作了数据库，这样是没问题的，以后最终不管是要commit还是rollback，总之都有开始事务时的标记，能够最终正确地提交或回滚，保证事务的正确执行。

　　在多线程环境中，不同线程可能同时操作同一块数据，这时不同事务之间就可能产生干扰，可能导致数据的不准确和不一致，这就是事务的隔离性（Isolation）问题。如果不考虑事务的隔离性，就可能出现以下问题：

　　（1）脏读：指一个线程中的事务读取到了另外一个线程中未提交的数据。

　　（2）不可重复读：指一个线程中的事务读取到了另外一个线程中提交的update的数据。

　　（3）虚读（也叫幻读）：指一个线程中的事务读取到了另外一个线程中提交的insert的数据。

　　下面举例说明何为脏读、不可重复读和虚读。首先打开两个连接到MySQL的控制台客户端（Navicat支持这样做），模拟同时执行的两个线程，可分别叫它们T1和T2线程以便区分。下面进行隔离性问题的模拟：

　　Step1：准备工作。

　　我们演示的account表。account表的原始数据是：

|    name    |    money    |
|:----------:|:-----------:|
|      A     |     1000    |
|      B     |     1000    |

　　首先在两个“线程”中都执行以下命令：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

　　该语句是设置MySQL的当前会话连接的隔离级别是最低的“READ UNCOMMITTED”级别，以便演示脏读、不可重复读和虚读。学完本节就知道这个的意义了。

　　然后，两个“线程”均使用“START TRANSACTION;”开启事务。

　　Step2：查询数据。

　　T1和T2线程都先查询account表中的数据：

```sql
SELECT * FROM account;
```

　　发现A和B账户都是1000元，没有问题。

　　Step3：演示脏读。

　　假设CPU先执行T1，T1中更新数据：

```sql
UPDATE account SET money = money + 100 WHERE name = 'A'; -- A减少100元
```

　　此时T1尚未提交，而T2抢占了CPU，T2通过SELECT语句查询数据，会发现A的账户变为1100元。这就是脏读，即线程T2读到了线程T1中未提交的数据。

　　Step4：演示不可重复读。

　　现在，在T1和T2中都执行rollback重回初始状态，重新执行Step1和Step2，跳过Step3。这时在T1中先更新数据并提交：

```sql
UPDATE account SET money = money + 100 WHERE name = 'A';
COMMIT;
```

　　此时在T2中查询数据，发现A的账户变为1100元。这就是不可重复读，线程T2读到了线程T1中提交的UPDATE数据。不可重复读的问题就是在一个事务范围内，两个相同的查询却返回了不同数据（例如Step2中的查询和Step4中的T2查询的数据不同，但是在一个事务内）。举例说明问题：例如，一个读者两次读取同一文档，但在两次读取之间，作者重写了该文档。当读者第二次读取文档时，文档已更改，导致原始数据读取不可重复。

　　Step5：演示虚读。

　　现在，重新执行Step1和Step2，然后T1线程插入一条数据并提交：

```sql
INSERT INTO account VALUES('C', 1000);
COMMIT;
```

　　T2再查询时发现多了一条数据。这就是虚读，即线程T2读到了线程T1中提交的INSERT数据。

　　以上出现的隔离性问题都是发生在并发情况下执行的事务中，且两个线程都分别是同一个事务范围内的。如果T2线程中执行的都不是一个事务范围内的语句，那么查询到不同数据当然是理所当然的（除了脏读），注意区分。

　　数据库一共提供了四种事务隔离级别，用于解决隔离性问题，列表如下：

|    名称    |    说明    |    备注    |
|:----------:|:----------:|:----------:|
|  READ UNCOMMITTED  |  脏读、不可重复读、虚读都有可能发生  |  隔离级别最低，并发性能高，无锁  |
|  READ COMMITTED  |  防止脏读发生，不可重复读、虚读都有可能发生  |  锁定正在读取的行  |
|  REPEATABLE READ  |  防止脏读、不可重复读的发生，虚读有可能发生  |  锁定所读取的所有行  |
|  SERIALIZABLE  |  防止脏读、不可重复读、虚读的发生  |  锁表  |

　　上述的级别从上到下是越来越高的，级别越高，数据越安全，但性能越低。因为要实现高级别的隔离，就需要更严格的加锁处理，就会导致并发降低。特别是SERIALIZABLE，如果应用了这个隔离级别，并发插入时，必须等待其他线程提交完毕才可插入，性能低。

　　MySQL的默认事务隔离级别是Repeatable Read，每个会话连接都可设置适合自己的隔离级别。设置当前会话连接隔离级别的方法是：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;
```

　　这里的隔离级别只要写上上表中对应的英文单词即可。可使用：

```sql
SELECT @@tx_isolation;
```

　　查看当前会话连接的隔离级别。读者可分别采用不同的隔离级别再按照上述的Step进行隔离性的验证。一般来说，隔离级别使用“READ COMMITTED”或者“REPEATABLE READ”即可。当然，设置事务的隔离级别一定要在开启事务前进行设置。

　　那么，怎么在JDBC中设置连接的隔离级别呢？Connection对象提供了setTransactionIsolation(int level)方法，该方法用于设置连接的隔离级别，可选用Connection中的常量：

```java
/**
 * 指示事务不受支持的常量
 */
int TRANSACTION_NONE             = 0;
/**
 * 指示防止发生脏读的常量，不可重复读和虚读有可能发生
 */
int TRANSACTION_READ_UNCOMMITTED = 1;
/**
 * 指示可以发生脏读、不可重复读和虚读的常量
 */
int TRANSACTION_READ_COMMITTED   = 2;
/**
 * 指示防止发生脏读、不可重复读的常量，虚读有可能发生
 */
int TRANSACTION_REPEATABLE_READ  = 4;
/**
 * 指示防止发生脏读、不可重复读和虚读的常量
 */
int TRANSACTION_SERIALIZABLE     = 8;
```

　　只要在开启事务之前设置隔离级别即可，例如：

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement stmt = null;
    Savepoint sp = null;
    try {
        conn = JdbcUtil.getConnection();
        // 设置隔离级别
        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        conn.setAutoCommit(false);
        stmt = conn.prepareStatement("UPDATE account SET money = money - 100 WHERE name = 'A'");
        stmt.executeUpdate();
        conn.commit();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        JdbcUtil.release(conn, stmt);
    }
}
```

# 3. DbUtils组件

　　commons-dbutils 是 Apache 组织的一个开源类库，它对JDBC进行了简单的封装。开发者使用DbUtils能提高开发效率，简化代码。

　　Apache的DbUtils项目地址：http://commons.apache.org/proper/commons-dbutils/ 。可自行下载工具包，然后在Java项目中引入“commons-dbutils-1.6.jar”这个JAR包。当然，不能忘了引入数据库驱动包。

　　使用DbUtils组件的一般步骤：

　　（1）创建一个QueryRunner对象；

　　（2）调用QueryRunner对象的方法来操作数据库，如update()方法，方法需要传递数据库连接、预编译的SQL和参数等信息。

　　（3）调用DBUtils的静态方法close()来关闭数据库连接。

　　下面进行详细讲解。

## 3.1 用QueryRunner的update()方法执行增删改操作

　　实例代码：

```java
package com.zhang.test;

import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        // 同样，先得到数据库连接对象
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        // 创建QueryRunner对象
        QueryRunner qr = new QueryRunner();
        // 调用qr的update()方法
        int rows = qr.update(conn, "insert into account values(?, ?);", "王五", 1000);
        System.out.println("影响行数：" + rows);
        // 关闭连接
        DbUtils.close(conn);
    }
}
```

　　其中update()方法可执行增删改操作，常用的重载（也是上述用的）：

　　public int update(Connection conn, String sql, Object... params)

　　参数1是数据库连接，参数2是预编译的SQL，最后一个可变参数，就是依次设置预编译SQL中的各个参数，可传递Object类型，DbUtils自行处理。发现使用DBUtils相比之前方便很多。

## 3.2 用batch()方法执行批处理操作

　　批处理操作也适合于增删改。使用batch()方法，原型为：

　　public int[] batch(Connection conn, String sql, Object[][] params)；同样参数1是数据库连接，参数2是SQL，参数3这时是一个二维数组，二维数组中有几个一维数组，就表示执行几次SQL，而一维数组中的数据就是设置SQL参数值的。

　　例子：

```java
package com.zhang.test;

import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        QueryRunner qr = new QueryRunner();
        qr.batch(conn, "insert into account values(?,?)", new Object[][]{
                {"张三", 1000},
                {"李四", 2000},
                {"王五", 3000}
        });
        DbUtils.close(conn);
    }
}
```

## 3.3 使用query()方法查询数据库

　　QueryRunner对象提供了query()方法用于获得SQL查询结果。query()的原型是：

```java
public <T> T query(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params)
```

　　参数1：数据库连接

　　参数2：预编译SQL

　　参数3：ResultSetHandler对象

　　参数4：预编译SQL的参数，若SQL无参数，则不写此参数，因为query()有三个参数的重载。

　　重点讲解的就是参数3。ResultSetHandler<T>是一个接口，因此我们要用它的一个实现类。实现类需要重写下列方法：

　　T handle(ResultSet rs)，即在此方法中，我们能拿到DbUtils传递过来的ResultSet结果集，我们自行处理即可。

　　query()和handler()中都使用了泛型T，说明我们实现ResultSetHandler时使用什么类型，那么query()的返回值就是什么类型。我们只要在handler()中操作结果集，返回我们想要的数据类型即可。

　　比如，查询的SQL是select * from Account，那么返回的数据类型应该是List<Account>，我们循环遍历ResultSet数据来封装一下实体类即可。

　　再比如，查询的SQL是select * from Employee where eid=?，由于是主键查询，返回的只应该是一个实体类Employee类(若无数据就返回null)，此时就不用循环结果集，直接用if(rs.next())...即可。

　　下面就实现上面的案例。

　　案例1：实现select * from Account。

　　（1）Account实体类

```java
package com.zhang.bean;

public class Account {
    private String name;
    private int money;

    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getMoney() {
        return money;
    }
    public void setMoney(int money) {
        this.money = money;
    }
    @Override
    public String toString() {
        return "Account{" +
                "name='" + name + '\'' +
                ", money=" + money +
                '}';
    }
}
```

　　（2）AccountHandler实现ResultSetHandler接口

```java
package com.zhang.test;

import com.zhang.bean.Account;
import org.apache.commons.dbutils.ResultSetHandler;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

// 由于query()的返回值要是List<Account>，因此这里的泛型参数就用List<Account>
public class AccountHandler implements ResultSetHandler<List<Account>> {
    @Override
    public List<Account> handle(ResultSet rs) throws SQLException {
        List<Account> accList = new ArrayList<>();
        while(rs.next()) {
            accList.add(new Account(rs.getString(1), rs.getInt(2)));
        }
        return accList;
    }
}
```

　　（3）主类

```java
package com.zhang.test;

import com.zhang.bean.Account;
import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;

import java.sql.*;
import java.util.List;

public class Demo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        QueryRunner qr = new QueryRunner();
        // query()的参数3就用AccountHandler对象，并且返回值是List<Account>。
        List<Account> accountList =  qr.query(conn, "select * from account", new AccountHandler());
        System.out.println(accountList);
        DbUtils.close(conn);
    }
}
```

　　案例2：实现select * from Employee where eid=?

　　（1）Employee实体类

```java
package com.zhang.bean;

public class Employee {
    private int eid; // 编号
    private String ename; //姓名
    public Employee(int eid, String ename) {
        this.eid = eid;
        this.ename = ename;
    }
    public int getEid() {
        return eid;
    }
    public void setEid(int eid) {
        this.eid = eid;
    }
    public String getEname() {
        return ename;
    }
    public void setEname(String ename) {
        this.ename = ename;
    }
    @Override
    public String toString() {
        return "Employee{" +
                "eid=" + eid +
                ", ename='" + ename + '\'' +
                '}';
    }
}
```

　　（2）SingleEmployeeHandler实现ResultSetHandler接口

```java
package com.zhang.test;

import com.zhang.bean.Employee;
import org.apache.commons.dbutils.ResultSetHandler;

import java.sql.ResultSet;
import java.sql.SQLException;

// 返回的就是一个Employee实体，因此直接用<Employee>
public class SingleEmployeeHandler implements ResultSetHandler<Employee> {
    @Override
    public Employee handle(ResultSet rs) throws SQLException {
        Employee emp = null;
        if(rs.next()) {
            emp = new Employee(rs.getInt(1), rs.getString(2));
        }
        return emp;
    }
}
```

　　（3）主类

```java
package com.zhang.test;

import com.zhang.bean.Employee;
import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        QueryRunner qr = new QueryRunner();
        // query()的参数3就用SingleEmployeeHandler
        Employee emp = qr.query(conn, "select * from employee where eid = ?", new SingleEmployeeHandler(), 12);
        System.out.println(emp);
        DbUtils.close(conn);
    }
}
```

　　也可以直接给参数3传递一个匿名内部类，实现其中的方法。此方式适用于此ResultSetHandler只需要使用一次的时候。例子：

```java
package com.zhang.test;

import com.zhang.bean.Employee;
import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;

import java.sql.*;

public class Demo {
    public static void main(String[] args) throws Exception {
        String url = "jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8";
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection(url, "root", "123456");
        QueryRunner qr = new QueryRunner();
        // query()的参数3就用SingleEmployeeHandler
        Employee emp = qr.query(conn, "select * from employee where eid = ?", new ResultSetHandler<Employee>() {
            @Override
            public Employee handle(ResultSet rs) throws SQLException {
                Employee emp = null;
                if(rs.next()) {
                    emp = new Employee(rs.getInt(1), rs.getString(2));
                }
                return emp;
            }
        }, 12);
        System.out.println(emp);
        DbUtils.close(conn);
    }
}
```

　　上述使用DbUtils实现了简单的对象关系映射（对象关系映射，即ORM，Object Relational Mapping），把数据库中的数据封装到对象中，实现用面向对象的方法操作数据。以后还会学习更强大的ORM框架，比如Hibernate和Mybatis。

# 4. 优化数据库连接：使用连接池

　　我们之前的案例中，会频繁打开和关闭一个数据库连接对象。而且在实际应用中，同时可能有多个数据库连接在使用，比如有n个用户正在查询自己的信息。

　　数据库连接资源是十分宝贵的，频繁打开关闭连接会耗费资源，并且实际中我们还需要管理多个连接资源。为了对数据库连接进行有效的管理，需要使用连接池技术：预先创建多个数据库连接（即连接池），当需要用到连接时，就从池中取出一个使用，用完后再放回池中。

　　可定义数据库连接池的“初始化连接数”、“最大连接数”等，并记录“当前连接数”，这样我们也能自行编写实现连接池的代码：当需要新连接时，若池中有空闲的，则直接从池中取；否则就新建连接，但是总连接数不能超过最大连接数，否则创建不成功，只能等待其他连接使用完毕才能获得连接。

　　实际上JDK已经规定了连接池的一系列规范，比如：连接池需要实现接口javax.sql.DataSource，这个DataSource是数据源，用于给外部提供数据库连接，这样就更加简化了我们获得数据库连接的方式。

　　自己实现连接池比较麻烦，一般使用第三方开源的连接池。常用的有DBCP和C3P0连接池。

　　注意，DBCP和C3P0只负责提供DataSource和管理数据库连接，并不是像DBUtils那样对JDBC操作进行了封装，因此为了简化数据库操作，可以结合连接池使用DBUtils。即连接池给DBUtils提供DataSource数据源。可以使用QueryRunner的构造函数重载QueryRunner(DataSource ds)，来通过数据源获得连接，这样update()、batch()和query()方法都不需要传递数据库连接对象Connection了，DBUtils提供了这样的重载。而且使用DataSource也不需要考虑手动关闭Connection连接，因为这些事是连接池做的。这样结合使用十分方便。

　　如果不使用DBUtils，单纯的使用DataSource对象的getConnection()方法也能轻松得到Connection连接对象。

## 4.1 DBCP连接池

　　DBCP是Apache的开源连接池实现，要使用DBCP，除了应该在项目中引入DBCP的jar包外，还应引入DBCP的两个依赖jar包，即commons-pool.jar和commons-logging.jar，这都是Apache的产品，可在Apache官网寻找下载。

　　DBCP可通过properties配置文件来配置数据库连接的参数，比如在src下新建db.properties文件，内容如下：

```properties
# 配置数据库驱动类
driverClassName=com.mysql.jdbc.Driver
# 连接的URL
url=jdbc:mysql://localhost:3306/mytest?useSSL=false&useUnicode=true&characterEncoding=utf8
# 用户名
username=root
# 密码
password=123456
# 设置初始化连接数
initialSize=5
# 最大连接数
maxActive=10
# 最大空闲时间。若超过这个时间此连接还是空闲，则回收此连接
maxIdle=6000
```

　　使用配置的好处就是可根据需要来配置数据库，而不需要重新更改代码并且重新编译代码。而之前的方式都是“硬编码”，即把所有的信息都在代码中写死的。我们也可通过自行通过IO方式来实现自己读取配置文件。以后大部分信息都是在配置文件中配置的，这样使得系统更加灵活。

　　在程序中，使用DBCP核心类BasicDataSourceFactory得到DataSource数据源。以下是结合DBUtils使用的案例：

```java
package com.zhang.test;

import org.apache.commons.dbcp2.BasicDataSourceFactory;
import org.apache.commons.dbutils.QueryRunner;

import javax.sql.DataSource;
import java.io.InputStream;
import java.util.Properties;

public class Demo {
    public static void main(String[] args) throws Exception {
        // 加载db.properties配置文件。为何使用ClassLoader.getSystemResourceAsStream()？参见本章附录。
        InputStream in = ClassLoader.getSystemResourceAsStream("db.properties");
        // 创建Properties对象装载配置文件
        Properties props = new Properties();
        // 装载
        props.load(in);
        // 使用BasicDataSourceFactory的方法，根据props对象得到数据源
        DataSource ds = BasicDataSourceFactory.createDataSource(props);
        // 可使用数据源创建QueryRunner
        QueryRunner qr = new QueryRunner(ds);
        int row = qr.update("insert into account values(?,?)", "王五", 10000);
        System.out.println(row);
        // 数据库连接无需自己关闭，由连接池管理
    }
}
```

　　在程序运行中，DBCP会自动维护连接池。当然程序结束之后，维护的连接也会随之关闭。我们可以在QueryRunner那一行设置一个断点，调试程序。当程序运行停在此断点处时，在MySQL中执行“show processlist”查看当前所有的数据库连接，可以看到连接池管理的所有连接的状态。

## 4.2 C3P0连接池

　　C3P0也是常用的连接池。C3P0的网址: http://www.mchange.com/projects/c3p0/ 。可在对应的Github上下载最新的C3P0文件：https://github.com/swaldman/c3p0/releases 。

　　使用C3P0需要引入lib目录下的jar包，如果不是连接Oracle数据库，则不用引入“c3p0-oracle-thin-extras-0.9.5.2.jar”文件，只需引入另两个文件。

　　C3P0使用xml文件来配置数据库连接。C3P0默认自动加载classpath路径下的c3p0-config.xml文件，因此我们在项目src目录下新建一个c3p0-config.xml文件，因为项目编译时，src目录下的配置文件会自动被复制到classpath路径下。配置内容如下：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<c3p0-config>
    <!-- default-config节点中的是默认配置，C3P0默认会加载此配置 -->
    <default-config>
        <!-- 配置连接URL。注意，在XML中，连接字符串中的&符号需要转义成&amp;否则出错 -->
        <property name="jdbcUrl">
            jdbc:mysql://localhost:3306/mytest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8
        </property>
        <property name="driverClass">com.mysql.jdbc.Driver</property>
        <property name="user">root</property>
        <property name="password">123456</property>
        <property name="initialPoolSize">3</property>
        <property name="maxPoolSize">6</property>
        <property name="maxIdleTime">6000</property>
    </default-config>
    <!-- 在default-config同级节点下，也能配置其他数据库连接，比如SQL Server的 -->
    <!-- 这里只是示例 -->
    <named-config name="sqlServer">
        <property name="jdbcUrl">jdbc:sqlserver://localhost:1433;databaseName=mytest</property>
        <property name="driverClass">com.microsoft.sqlserver.jdbc.SQLServerDriver</property>
        <property name="user">sa</property>
        <property name="password">123456</property>
        <property name="initialPoolSize">3</property>
        <property name="maxPoolSize">6</property>
        <property name="maxIdleTime">6000</property>
    </named-config>
</c3p0-config>
```

　　C3P0直接用核心类ComboPooledDataSource创建对象，该对象就能当做DataSource使用，因为此类最终还是实现了DataSource接口。代码：

```java
package com.zhang.test;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;

public class Demo {
    public static void main(String[] args) throws Exception {
        // 创建ComboPooledDataSource对象，实际上就是数据源
        ComboPooledDataSource ds = new ComboPooledDataSource();
        //ComboPooledDataSource默认使用XML中default-config节点中的信息。
        //如果想使用非默认的配置节点信息，则创建此对象时要传入该配置的名字，即：
        //ComboPooledDataSource dataSource = new ComboPooledDataSource("sqlserver");
        
        // 用ds创建QueryRunner
        QueryRunner qr = new QueryRunner(ds);
        qr.update("insert into account values(?,?)", "张三", 130000);
        System.out.println("OK");
    }
}
```

　　程序运行中，控制台会输出一系列的红色信息，这并不是警告和错误，而是C3P0提供的日志信息。日志中提供了时间和其他的信息，日志也能提供调试、警告和错误等信息，在开发过程中使用能清晰的知道系统运行的状况。

　　总结：推荐以后的应用都使用连接池，即方便开发又提高效率。

# 附1：JDBC连接SQL Server数据库

　　步骤如下：

　　（1）下载适用于SQL Server的JDBC驱动，网址：https://www.microsoft.com/zh-CN/download/details.aspx?id=11774 。下载tar.gz压缩包即可。下载前可看看页面上的说明。在“系统要求”中可知道，若使用Java8，则可使用Sqljdbc42.jar包，支持的数据库版本是SQL Server2008——2016。

　　（2）解压压缩包，拿到jre8目录中的jar文件，引用到项目中。

　　（3）然后即可正常写Java代码。注意的是：数据库连接url格式为：jdbc:sqlserver://IP地址:端口;databaseName=数据库名；需要加载的驱动类为：com.microsoft.sqlserver.jdbc.SQLServerDriver。SQLServer默认端口是1433。

　　（4）Java代码中使用sa账户和密码验证。这时可成功连接数据库。示例代码：

```java
Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
Connection conn = DriverManager.getConnection("jdbc:sqlserver://localhost:1433;databaseName=MyTest", "sa", "123456");
```

　　有时不能正常连接数据库，则检查SQL Server服务是否打开了，并且还要保证SQL Server的网络配置正常：打开“Sql Server Configuration Manager”，设置“MSSQLSERVER的协议”中，TCP/IP为“启用”状态，如图：

![](images/10/f-1.png)

　　若使用外界的计算机访问本地数据库，即远程访问，那么本机也需要在防火墙中配置1433端口为“允许入站”，方法和MySQL配置时方法一致。

　　另外，学习过.Net的人还会使用Windows连接验证方式，这样无需使用密码，但是不推荐这样做，并且这样做较麻烦。步骤如下：

　　（1）数据库连接url使用Windows验证，即加上“integratedSecurity=true”，比如：“jdbc:sqlserver://localhost:1433;databaseName=MyTest;integratedSecurity=true”。

　　（2）Java代码中无需写用户名和密码，即：“DriverManager.getConnection(url)”即可。

　　（3）仅仅上述步骤会出错。还需要向Windows系统注册一个“sqljdbc_auth.dll”的文件。该文件在压缩包的auth文件夹中已经提供了。根据自己电脑位数选择合适的版本注册。有两种注册的方法：1.把该dll所在文件夹添加为Path环境变量；2.把该dll文件添加到“C:/Windows/System32”文件夹中。

　　温馨提示：连接SQL Server数据库时，也能使用DBUtils组件和连接池技术（DBCP和C3P0）。只是需要注意下述问题：

　　使用DBUtils时，SQL Server不能正确识别处理预编译的SQL语句，需要在创建QueryRunner对象时，提供一个knowParaType参数，此参数类型是boolean，设置为true即可。比如：

　　QueryRunner qr = new QueryRunner(true)；

　　当使用数据库连接池提供的DataSource数据源时，也别忘了提供此参数：

　　QueryRunner qr = new QueryRunner(ds, true);
